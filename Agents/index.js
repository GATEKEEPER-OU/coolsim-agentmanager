// init agents from users, registers agents in users status

// each agent is initialised with:
// 1) the community clock
// 2) condition generator
// 3) status generator
// 4) event generator
// 5) action generator

// agent has internal phases defined by
// list of actions he can perform
// preferences
// in training
// use emerging events as a malus for the next round of actions


// going out of the area > bring modifiers

// the delta of outcomes > create new conditions? or trigger emergency?

// pipeline of interventions to be done, eventually the next day?

// degree of relations between agents
import uniqid from 'uniqid';
import Actions from '../Actions/index.js';
import Conditions from '../Conditions/index.js';
import Interact from "../Interact/index.js";
import Utils from '../../Utils/index.js';
import Profile from "./profile.js";
import Status from "./status.js";

const Time = Utils.time;
const Messages = Interact.messaging;
const Rate = Utils.rate;
const mergeMaps = Utils.mergeMaps;


export default class Agent{
    // input the state of the agent
    // {age, conditions, state, role, skills}
    // otherwise it is generated by the class
    HOURS = 24;

    Profile = new Profile();
    Status = Status;

    LOG = false;

    constructor(agent = {},
                clock = new Time.Clock('day'),
                board ){
        // time to allocate during the day
        this.clock = clock;

        // generate a profile
        let profile = this.Profile.profile;

        let {
            id = profile.id,
            age = profile.age,
            day = 0,
            conditions,
            simulation = uniqid("sim-"),
            role = profile.role,
            skills = profile.skills,
            status = profile.status,
            yearOfBirth = clock.yearOfBirth(profile.age)
        } = agent;

        this.id = id;
        this.day = day;
        this.status = status;

        this.simulation = simulation;
        this.yearOfBirth = yearOfBirth;

        // init role
        this.role = this.Profile.getRole(role);
        // console.log('agent role',this.role);
        //init skills (provided or randomly generated
        this.skills = this.Profile.getSkills(skills);
        // console.log('agent skills',this.skills);

        // init helpers
        this.actionsHelper = new Actions();
        // init conditions helper
        this.conditionsHelper = new Conditions({age:age,conditions});
        // status helper
        this.statusHelper = new Status(this.status);

        // todo check which monitoring system apply
        // generate a list using rates

        // if billboard provided, enable messaging
        if(board){
            this.messaging = new Messages(board);
        }

        // save
    }
    get age(){
        return this.clock.age(this.yearOfBirth);
    }


    // returns an array with the current conditions of the agent
    get conditions(){
        return Array.from(this.conditionsHelper.status);
    }
    get stats(){
        return this.conditionsHelper.stats;
    }

    get getDescription(){
        return {
            id: this.id,
            simulation: this.simulation,
            day:this.day,
            role:this.role,
            final:this.final,
            skills: this.skills,
            status: this.statusHelper.current,
            yearOfBirth: this.yearOfBirth,
            age: this.age,
            stats: this.stats,
        };
    }


    //
    async dailyRoutine(events = []){
        // console.log("3",events);
        return new Promise((resolve, reject)=>{
            let time = 0;

            // console.log("4",this.final);
            // check if the agent closed its lifecycle
            if(this.final){
                resolve({status:this.status,final:true,id:this.id});
            }
            // console.log("5");
            let eventsOutcomes = this._evaluateEvents(events);
            // console.log("6",eventsOutcomes);
            // update time spent
            time += eventsOutcomes.time;


            // todo check inbox


            // daily actions
            let {choices, actionsOutcomes} = this._dailyActions(this.conditions,time);
            time += actionsOutcomes.time;

            // todo visits


            // evaluate the day
            let {issues, emergingConditions} = this._assessDayOutcomes({actionsOutcomes,eventsOutcomes});

            // check for a change of status
            this.status = this.statusHelper.check(this.status);
            this.final = this.statusHelper.final;



            // console.log("10",newStatus);
            // update days counter
            this.day ++;


            // logs the day
            let day = {
                agent:this.id,
                day:this.day,
                time,
                final:this.final,
                events:{
                    list: events.map(e=>e.label),
                    outcomes:{
                        positive:Utils.mapToObject(eventsOutcomes.positive),
                        negative:Utils.mapToObject(eventsOutcomes.negative)
                    },
                    time: eventsOutcomes.time
                },
                activities: {
                    actions: choices.actions.map(e=>e.label),
                    skips: choices.skips.map(e=>e.label),
                    time: actionsOutcomes.time,
                    outcomes:{
                        positive:Utils.mapToObject(actionsOutcomes.positive),
                        negative:Utils.mapToObject(actionsOutcomes.negative)
                    }
                },
                issues:{
                    emerging: issues,
                    outcomes: Utils.mapToObject(emergingConditions)
                }
            };

            // console.log("11",day);
            this._log(day);
            resolve(day);
        });
    }




    _evaluateEvents(events){
        // evaluate impact of events
        // console.log('today events',events);
        let eventsEffects = events.reduce((partial,event)=>{
            // console.log(event.effects);
            partial.action = partial.action.concat(event.action);
            partial.condition = partial.condition.concat(event.condition);
            return partial;
        },{action:[],condition:[]});
        // console.log('effects of events, actions\n',eventsEffects.action);
        // console.log('effects of events, conditions\n',eventsEffects.condition);
        // add conditions
        this.conditionsHelper.add(eventsEffects.condition);

        // assess events actions
        return this.actionsHelper.outcomes(eventsEffects.action,[],this.conditionsHelper.list);
    }

    _dailyActions(conditions,time){
        // get reminders of daily activities
        let dailies = this.actionsHelper.remind(conditions);
        // console.log("7",dailies);
        // decide what to do and skip
        let choices = this._decideActions(dailies);
        // console.log("8",choices);
        // IMPORTANT it can be done in bulk or cycle (for the sake of logs)
        // evaluate outcomes of actions
        let actionsOutcomes = this.actionsHelper.outcomes(
            choices.actions,
            choices.skips,
            this.conditionsHelper.list,
            time);
        // console.log("9",actionsOutcomes);


        return {choices, actionsOutcomes};
    }


    // decide how to allocate daily hours
    _decideActions(dailies) {
        let choices = dailies.reduce((partial, action) => {
            if (partial.allocated <= this.HOURS && Rate.test(action.rate)) {
                partial.allocated += action.duration.hours;
                partial.actions.push(action);
            } else {
                partial.skips.push(action);
            }
            return partial;
        }, {actions: [], skips: [], allocated: 0});
        // console.log(`Allocated ${choices.allocated} hours`);
        // console.log('what agent wish to do', choices.actions);
        // console.log('what agent wish to skip', choices.skips);
        return choices;
    }


    _assessDayOutcomes({actionsOutcomes,eventsOutcomes}){
        // IMPORTANT AS BULK //
        // translate outcomes to conditions
        let positive = this._mergeOutcomes([actionsOutcomes.positive,eventsOutcomes.positive]);
        let negative = this._mergeOutcomes([actionsOutcomes.negative,eventsOutcomes.negative]);
        // console.log('consolidate positive',positive);
        // console.log('consolidate negative',negative);
        let issues = this.conditionsHelper.assess(positive,negative);
        // console.log('emerging issues',issues);
        // issues : object {type:weight} (condition type)
        // add for emerging conditions using emerging issues
        let emergingConditions = this.conditionsHelper.addIssues(issues);

        return {issues, emergingConditions};
    }


    _mergeOutcomes(list=[]){
        return list.reduce((partial,outcomes)=>{
            return mergeMaps(partial,outcomes);
        },);
    }


    _log(entry){
        if(this.LOG) {
            console.log(`This morning I got involved for ${entry.events.time} hours in\n`,entry.events.list.join(", "));
            console.log('With outcomes \n',entry.events.outcomes);
            console.log('About my activities');
            console.log(`I spent ${entry.activities.time} hours doing: \n`,entry.activities.actions.join(", "));
            console.log('With these positive outcomes: \n',entry.activities.outcomes.positive);
            console.log(`But I did not manage to: \n`,entry.activities.skips.join(", "));
            console.log('With these negative outcomes',entry.activities.outcomes.negative);
            console.log(`At the end of the day, i have the following:\n`,entry.state.conditions.map(e=>e.duration+" "+e.label).join(", "));
            console.log(`Which results in being "${entry.state.status.label}"`);
            console.log(`Here my stats`,entry.state.stats);
            console.log(`With new emerging issues: \n`,entry.state.issues.emerging);
            console.log(`and outcomes:\n`,entry.state.issues.outcomes);
            console.log("1");
        }
    }

};